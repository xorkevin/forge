package validation

import (
	"io/fs"
	"testing"
	"testing/fstest"
	"time"

	"github.com/stretchr/testify/require"
	"xorkevin.dev/forge/writefs"
)

func TestGenerate(t *testing.T) {
	t.Parallel()

	now := time.Now()
	var filemode fs.FileMode = 0644

	for _, tc := range []struct {
		Name   string
		Fsys   fs.FS
		Output map[string]string
		Err    error
	}{
		{
			Name: "parses directives from files",
			Fsys: fstest.MapFS{
				"stuff.go": &fstest.MapFile{
					Data: []byte(`package somepackage

type (
	//forge:valid
	reqSearchUsers struct {
		Prefix string ` + "`" + `valid:"username,opt" json:"-"` + "`" + `
		Amount int    ` + "`" + `valid:"amount" json:"-"` + "`" + `
	}

	//forge:validnope
	reqOther struct {
		Prefix string ` + "`" + `valid:"username,opt" json:"-"` + "`" + `
		Amount int    ` + "`" + `valid:"amount" json:"-"` + "`" + `
	}

	//forge:valid
	reqGetUsers struct {
		Userids []string ` + "`" + `valid:"userids,has" json:"-"` + "`" + `
		Foo string ` + "`" + `json:"foo"` + "`" + `
	}
)
`),
					Mode:    filemode,
					ModTime: now,
				},
				"more.go": &fstest.MapFile{
					Data: []byte(`package somepackage

type (
	//forge:valid
	reqAnother struct {
		Prefix string ` + "`" + `valid:"username,opt" json:"-"` + "`" + `
		Amount int    ` + "`" + `valid:"amount" json:"-"` + "`" + `
	}
)
`),
					Mode:    filemode,
					ModTime: now,
				},
				"stuff_again.go": &fstest.MapFile{
					Data: []byte(`package somepackage

type (
	//forge:valid
	reqAgain struct {
		Prefix string ` + "`" + `valid:"username,opt" json:"-"` + "`" + `
		Amount int    ` + "`" + `valid:"amount" json:"-"` + "`" + `
	}
)
`),
					Mode:    filemode,
					ModTime: now,
				},
				"morestuff.go": &fstest.MapFile{
					Data: []byte(`package somepackage

type (
	//forge:valid
	reqUserGetID struct {
		Userid string ` + "`" + `valid:"userid,has" json:"-"` + "`" + `
	}
)
`),
					Mode:    filemode,
					ModTime: now,
				},
			},
			Output: map[string]string{
				"validation_gen.go": `// Code generated by go generate forge validation dev; DO NOT EDIT.

package somepackage

func (r reqUserGetID) valid() error {
	if err := validhasUserid(r.Userid); err != nil {
		return err
	}
	return nil
}

func (r reqSearchUsers) valid() error {
	if err := validoptUsername(r.Prefix); err != nil {
		return err
	}
	if err := validAmount(r.Amount); err != nil {
		return err
	}
	return nil
}

func (r reqGetUsers) valid() error {
	if err := validhasUserids(r.Userids); err != nil {
		return err
	}
	return nil
}
`,
			},
		},
		{
			Name: "errors on wrong package",
			Fsys: fstest.MapFS{
				"stuff.go": &fstest.MapFile{
					Data: []byte(`package different
`),
					Mode:    filemode,
					ModTime: now,
				},
			},
			Err: ErrorEnv{},
		},
		{
			Name: "errors on no validations",
			Fsys: fstest.MapFS{
				"stuff.go": &fstest.MapFile{
					Data: []byte(`package somepackage
`),
					Mode:    filemode,
					ModTime: now,
				},
			},
			Err: ErrorInvalidFile{},
		},
		{
			Name: "errors on validation directive on non-struct",
			Fsys: fstest.MapFS{
				"stuff.go": &fstest.MapFile{
					Data: []byte(`package somepackage

//forge:valid
const (
	foo = "bar"
)
`),
					Mode:    filemode,
					ModTime: now,
				},
			},
			Err: ErrorInvalidFile{},
		},
	} {
		tc := tc
		t.Run(tc.Name, func(t *testing.T) {
			t.Parallel()

			assert := require.New(t)

			outputfs := writefs.NewFSMock()
			err := Generate(outputfs, tc.Fsys, Opts{
				Verbose:     false,
				Version:     "dev",
				Output:      "validation_gen.go",
				Prefix:      "valid",
				PrefixValid: "valid",
				PrefixHas:   "validhas",
				PrefixOpt:   "validopt",
				Include:     "stuff",
				Ignore:      `_again\.go$`,
				Directive:   "forge:valid",
				Tag:         "valid",
			}, ExecEnv{
				GoPackage: "somepackage",
			})
			if err != nil {
				assert.ErrorIs(err, tc.Err)
				return
			}
			assert.NoError(err)
			assert.Len(outputfs.Files, len(tc.Output))
			for k, v := range tc.Output {
				assert.Equal(v, outputfs.Files[k])
			}
		})
	}
}
