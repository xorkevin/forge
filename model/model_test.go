package model

import (
	"io/fs"
	"testing"
	"testing/fstest"
	"time"

	"github.com/stretchr/testify/require"
	"xorkevin.dev/forge/writefs"
)

func TestGenerate(t *testing.T) {
	t.Parallel()

	now := time.Now()
	var filemode fs.FileMode = 0644

	for _, tc := range []struct {
		Name   string
		Fsys   fs.FS
		Output map[string]string
		Err    error
	}{
		{
			Name: "parses directives from files",
			Fsys: fstest.MapFS{
				"stuff.go": &fstest.MapFile{
					Data: []byte(`package somepackage

type (
	//forge:model user
	Model struct {
		Userid string ` + "`" + `model:"userid,VARCHAR(31) PRIMARY KEY" query:"userid;getoneeq,userid;deleq,userid"` + "`" + `
		Username string ` + "`" + `model:"username,VARCHAR(255) NOT NULL UNIQUE;index,first_name" query:"username;getoneeq,username"` + "`" + `
		FirstName string ` + "`" + `model:"first_name,VARCHAR(255) NOT NULL" query:"first_name"` + "`" + `
	}

	//forge:query user
	userProps struct {
		Username string ` + "`" + `query:"username;updeq,userid"` + "`" + `
		FirstName string ` + "`" + `query:"first_name"` + "`" + `
	}

	//forge:query user
	Info struct {
		Userid string ` + "`" + `query:"userid;getgroup;getgroupeq,userid|in"` + "`" + `
		Username string ` + "`" + `query:"username;getgroupeq,username|like"` + "`" + `
	}

	//forge:modelnope
	reqOther struct {
		Prefix string
		Amount int
	}
)
`),
					Mode:    filemode,
					ModTime: now,
				},
			},
			Output: map[string]string{
				"model_gen.go": `// Code generated by go generate forge model dev; DO NOT EDIT.

package somepackage

import (
	"context"
	"fmt"
	"strings"
	"xorkevin.dev/governor/service/db"
)

type (
	userModelTable struct {
		TableName string
	}
)

func (t *userModelTable) Setup(ctx context.Context, d db.SQLExecutor) error {
	_, err := d.ExecContext(ctx, "CREATE TABLE IF NOT EXISTS "+t.TableName+" (userid VARCHAR(31) PRIMARY KEY, username VARCHAR(255) NOT NULL UNIQUE, first_name VARCHAR(255) NOT NULL);")
	if err != nil {
		return err
	}
	_, err = d.ExecContext(ctx, "CREATE INDEX IF NOT EXISTS "+t.TableName+"_first_name__username_index ON "+t.TableName+" (first_name, username);")
	if err != nil {
		return err
	}
	return nil
}

func (t *userModelTable) Insert(ctx context.Context, d db.SQLExecutor, m *Model) error {
	_, err := d.ExecContext(ctx, "INSERT INTO "+t.TableName+" (userid, username, first_name) VALUES ($1, $2, $3);", m.Userid, m.Username, m.FirstName)
	if err != nil {
		return err
	}
	return nil
}

func (t *userModelTable) InsertBulk(ctx context.Context, d db.SQLExecutor, models []*Model, allowConflict bool) error {
	conflictSQL := ""
	if allowConflict {
		conflictSQL = " ON CONFLICT DO NOTHING"
	}
	placeholders := make([]string, 0, len(models))
	args := make([]interface{}, 0, len(models)*3)
	for c, m := range models {
		n := c * 3
		placeholders = append(placeholders, fmt.Sprintf("($%d, $%d, $%d)", n+1, n+2, n+3))
		args = append(args, m.Userid, m.Username, m.FirstName)
	}
	_, err := d.ExecContext(ctx, "INSERT INTO "+t.TableName+" (userid, username, first_name) VALUES "+strings.Join(placeholders, ", ")+conflictSQL+";", args...)
	if err != nil {
		return err
	}
	return nil
}
`,
			},
		},
	} {
		tc := tc
		t.Run(tc.Name, func(t *testing.T) {
			t.Parallel()

			assert := require.New(t)

			outputfs := writefs.NewFSMock()
			err := Generate(outputfs, tc.Fsys, Opts{
				Verbose:        true,
				Version:        "dev",
				Output:         "model_gen.go",
				Include:        "stuff",
				Ignore:         `_again\.go$`,
				ModelDirective: "forge:model",
				QueryDirective: "forge:query",
				ModelTag:       "model",
				QueryTag:       "query",
			}, ExecEnv{
				GoPackage: "somepackage",
			})
			if err != nil {
				assert.ErrorIs(err, tc.Err)
				return
			}
			assert.NoError(err)
			assert.Len(outputfs.Files, len(tc.Output))
			for k, v := range tc.Output {
				assert.Equal(v, outputfs.Files[k])
			}
		})
	}
}
